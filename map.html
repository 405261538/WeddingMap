<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>WeddingMap</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link rel="preload" as="image" href="https://i.meee.com.tw/pFhTRSj.png">
    <link rel="stylesheet" href="styles.css">
    <script src="guests.js"></script>
</head>

<body>

    <div id="loading-screen">
        <div class="loader">載入中...</div>
    </div>
    <div id="orientation-overlay">
        <div class="phone-icon"></div>
        <div>請將手機旋轉至橫向模式</div>
    </div>
    <div id="page-content" style="display:none;">
        <div class="scene">
            <div class="book">
                <div class="page left"></div>
                <div class="page right"></div>
            </div>
            <svg id="svgCanvas" viewBox="0 0 1920 2307" class="fullscreen-background"
                preserveAspectRatio="xMidYMid meet">

                <!-- 背景圖片 -->
                <image href="https://i.meee.com.tw/dZiudH2.jpg" class="background" x="0" y="0" width="1920"
                    height="2307" />

                <!-- 路線 -->
                <path id="route" fill="transparent" stroke="black" stroke-width="2" d="" visibility="hidden" />

                <!-- 定義向下的弧形路徑 -->
                <defs>
                    <!-- 從左到右，弧形向下 -->
                    <path id="arcPathDown" d="M840,1942 A300,400 0 0,0 1080,1942" fill="transparent" />
                    <path id="motionPath" d="" fill="transparent" />
                </defs>
                <g id="ribbonGroup">
                    <!-- 前景圖片 -->
                    <image href="https://i.meee.com.tw/5VqdeNQ.png" class="ribbon" x="860" y="1900" width="200"
                        height="100" />

                    <!-- 文字沿向下弧形排列 -->
                    <text font-size="26" font-weight="bold" fill="#5C3426">
                        <textPath id="guestName" href="#arcPathDown" class="ribbon" startOffset="50%" text-anchor="middle">
                        </textPath>
                    </text>
                    <!-- 沿路線移動動畫 -->
                    <animateMotion id="motionAnim" dur="20s" repeatCount="1" begin="indefinite" fill="freeze">
                        <mpath href="#motionPath" />
                    </animateMotion>
                </g>

            </svg>

            <div class="line-vertical"></div>

            <img id="Slytherin" class="colleges" style="left:93px" src="https://i.meee.com.tw/z6jyuTN.png"
                alt="Slytherin">
            <img id="Hufflepuff" class="colleges" style="left:284px" src="https://i.meee.com.tw/KSE8csC.png"
                alt="Hufflepuff">
            <img id="Gryffindor" class="colleges" style="left:542px" src="https://i.meee.com.tw/TdIjOoA.png"
                alt="Gryffindor">
            <img id="Ravenclaw" class="colleges" style="left:735px" src="https://i.meee.com.tw/zmxSXuE.png"
                alt="Ravenclaw">
            <img id="door-left" class="door" style="left:375px" src="https://i.meee.com.tw/EhK8iZB.png">
            <img id="door-right" class="door" style="left:490px" src="https://i.meee.com.tw/EhK8iZB.png">
            <!-- <img id="chair" class="chair" style="left:490px" src="https://i.meee.com.tw/rV2UGjU.png"> -->
            <!-- <img id="door-font" class="door-font" src="https://i.meee.com.tw/ZNb98qo.png"> -->
        </div>
    </div>

    <script>
        var colleges = ["Slytherin", "Hufflepuff", "Gryffindor", "Ravenclaw"];
        var baseTop = {
            "Gryffindor": 75,
            "Hufflepuff": 75,
            "Ravenclaw": 75,
            "Slytherin": 75
        };

        //#region 圖片載入檢核

        // 要檢查的圖片清單
        const requiredImages = [
            "https://i.meee.com.tw/pFhTRSj.png",
            "https://i.meee.com.tw/dZiudH2.jpg",
            "img/left-footprint.png",
            "img/right-footprint.png"
        ];

        let loadedCount = 0;

        function checkAllLoaded() {
            if (loadedCount === requiredImages.length) {
                // 兩張圖片都載入完成 → 顯示內容
                document.getElementById("loading-screen").style.display = "none";
                document.getElementById("page-content").style.display = "block";

                // 背景淡入效果
                document.querySelector(".background").style.opacity = "1";
            }
        }

        requiredImages.forEach(src => {
            const img = new Image();
            img.src = src;

            img.onload = function () {
                loadedCount++;
                checkAllLoaded();
            };

            img.onerror = function () {
                console.error(src + " 載入失敗");
                loadedCount++;
                checkAllLoaded(); // 即使失敗也不要卡住
            };
        });
        //#endregion

        $(function () {

            // 初始化檢查
            checkOrientation();

            // 當螢幕方向改變時檢查
            window.addEventListener("orientationchange", checkOrientation);
            window.addEventListener("resize", checkOrientation);



            //封面翻頁
            $(".scene").on("click", function () {

                if ($(this).data("opened")) return;
                $(this).data("opened", true);

                // 背景漸顯 & 縮回原比例
                $(".background").css({
                    "transform": "scale(1)",
                    "opacity": "1"
                });

                // 左頁翻開並淡出
                $(".left").animate(
                    { deg: -180 },
                    {
                        duration: 5000,
                        step: function (now) {
                            $(this).css("transform", "rotateY(" + now + "deg)");
                            $(this).css("opacity", 1 - Math.abs(now) / 180);
                        }
                    }
                );

                // 右頁翻開並淡出
                $(".right").animate(
                    { deg: 180 },
                    {
                        duration: 5000,
                        step: function (now) {
                            $(this).css("transform", "rotateY(" + now + "deg)");
                            $(this).css("opacity", 1 - Math.abs(now) / 180);
                        },
                        complete: function () {
                            // 依序顯示學院
                            colleges.forEach(function (id, index) {
                                $('#' + id).animate({ opacity: 1 }, 500, function () {
                                    floatElement(id); // 顯示完成後啟動漂浮
                                });
                            });

                            // 總延遲等學院都出現完後再捲動場景
                            setTimeout(function () {
                                $(".scene").css("overflow-y", "auto").animate(
                                    { scrollTop: $(".scene")[0].scrollHeight },
                                    3000,
                                    function () {
                                        // 捲動完成後打開門
                                        $('#door-left').css({
                                            "transform-origin": "0% 100%",
                                            "transform": "rotate(-15deg)"
                                        });

                                    }
                                );
                            }, 500 + 1500);

                            setTimeout(function () {
                                $('.ribbon').css({
                                    "opacity": "1"
                                });

                            }, 500 + 1500 + 5000);

                            setTimeout(function () {
                                setInterval(updateFootprints, intervalTime); // 設定間隔，定期更新腳印位置
                            }, 500 + 1500 + 8000);

                        }
                    }
                );
            });


            let seatId = getSeatIdFromURL();
            if (seatId) {
                onScanQRCode(seatId);
            }

        });


        //#region 腳印相關（已修正：同步 ribbon / pause / restart 邏輯）
        const route = document.getElementById('route');
        const svg = document.getElementById('svgCanvas');
        const motionPath = document.getElementById('motionPath');
        const motionAnim = document.getElementById('motionAnim');
        const ribbonGroup = document.getElementById("ribbonGroup"); // 取得 ribbon group

        let currentPosition = 0;
        let isLeftFoot = true;
        const footOffset = 10; // 腳印與路徑的偏移量
        const intervalTime = 400; // 每400ms產生一個腳印
        const disappearTime = 2300; // 腳印多久後開始淡出（毫秒）

        // 新增狀態控制變數
        let isAnimatingRibbon = false;   // ribbon 是否正在播放
        let waitingRestart = false;      // 是否在 3 秒等待期
        let cycleTimeoutId = null;       // ribbon 完成的 timeout id
        let restartTimeoutId = null;     // 3 秒等待期的 timeout id

        function createFootprint(x, y, isLeft, rotation) {
            let footprint = document.createElementNS("http://www.w3.org/2000/svg", "image");
            footprint.setAttribute("href", isLeft ? "img/left-footprint.png" : "img/right-footprint.png");
            footprint.setAttribute("x", x);
            footprint.setAttribute("y", y);
            footprint.setAttribute("width", 25);
            footprint.setAttribute("height", 25);
            footprint.setAttribute("opacity", 1);
            footprint.setAttribute("class", "footprint");

            // 設置旋轉角度（以圖片中心為旋轉點）
            footprint.setAttribute("transform", `rotate(${rotation}, ${x + 12.5}, ${y + 12.5})`);

            svg.appendChild(footprint);

            // 設定計時器，讓腳印在一段時間後淡出並移除
            setTimeout(() => {
                footprint.style.transition = "opacity 1s";
                footprint.style.opacity = 0;
                setTimeout(() => {
                    if (svg.contains(footprint)) svg.removeChild(footprint);
                }, 1000);
            }, disappearTime);
        }

        // 啟動一個新的循環（包含：重置位置、設定 ribbon dur、開始 ribbon，並在 ribbon 結束後進入 3 秒等待）
        function startCycle() {
            if (isAnimatingRibbon || waitingRestart) return; // 已在播放或等待中就跳過
            const pathLength = route.getTotalLength();
            if (!pathLength || pathLength <= 0) return;

            // 重新顯示 ribbon
            ribbonGroup.style.display = "block";
            ribbonGroup.removeAttribute("transform");  // 清掉上次 freeze 停留的 transform
            // 重置參數
            currentPosition = 0;
            isLeftFoot = true;

            // 計算 dur（和腳印步調一致）
            const steps = Math.max(1, Math.ceil(pathLength / 25));
            const totalTime = steps * intervalTime; // 毫秒
            motionAnim.setAttribute("dur", (totalTime / 1000) + "s");

            // 啟動 ribbon
            isAnimatingRibbon = true;
            motionAnim.beginElement();
            //console.log("startCycle: begin ribbon, dur(ms) =", totalTime);

            // 清除舊的 timeout（保險）
            if (cycleTimeoutId) clearTimeout(cycleTimeoutId);
            if (restartTimeoutId) clearTimeout(restartTimeoutId);
            
            // 當 ribbon 演完後，轉為等待狀態（3 秒），再允許下一輪 startCycle()
            cycleTimeoutId = setTimeout(() => {
                isAnimatingRibbon = false;
                waitingRestart = true;
                //console.log("ribbon finished -> waiting 3s before restart");

                /*
                // 3 秒後結束等待並自動啟動下一輪
                restartTimeoutId = setTimeout(() => {
                    waitingRestart = false;
                    //console.log("waiting finished -> start next cycle");
                    startCycle();
                }, 3000);
                */
            }, totalTime + 50); // 加一點 buffer 確保 SMIL 已完成
        }

        // 每個 interval 呼叫：只在 ribbon 播放時才製造腳印；在等待期中完全跳過
        function updateFootprints() {
            const pathLength = route.getTotalLength();
            if (!pathLength || pathLength <= 0) return;

            // 如果正在等待重啟（3 秒），不做任何事
            if (waitingRestart) return;

            // 如果 ribbon 尚未啟動（第一次或上一輪結束），啟動一輪，但不在同一 tick 產生腳印（下個 interval 開始）
            if (!isAnimatingRibbon) {
                startCycle();
                return;
            }

            // 如果在播放中，產生腳印
            // 防止 getPointAtLength 超過 path 長度
            const safePos = Math.min(currentPosition, pathLength);
            const safeNext = Math.min(currentPosition + 5, pathLength);

            const point = route.getPointAtLength(safePos);
            const nextPoint = route.getPointAtLength(safeNext); // 預測下一步

            let angle = Math.atan2(Math.round(nextPoint.y) - Math.round(point.y),
                Math.round(nextPoint.x) - Math.round(point.x))
                * (180 / Math.PI);

            // 偵測轉彎（平滑角度）
            const furtherPoint = route.getPointAtLength(Math.min(currentPosition + 20, pathLength));
            let nextAngle = Math.atan2(Math.round(furtherPoint.y) - Math.round(nextPoint.y),
                Math.round(furtherPoint.x) - Math.round(nextPoint.x))
                * (180 / Math.PI);
            // nextAngle = nextAngle < -90 ? -90 : nextAngle;
            let angleDifference = nextAngle - angle;
            if (Math.abs(angleDifference) > 10) {
                angle += angleDifference / 2;
            }

            let offsetX = Math.cos((angle + 90) * Math.PI / 180) * footOffset;
            let offsetY = Math.sin((angle + 90) * Math.PI / 180) * footOffset;

            let leftX = point.x - offsetX;
            let leftY = point.y - offsetY;
            let rightX = point.x + offsetX;
            let rightY = point.y + offsetY;
            let deviation = angle >= 90 ? 5 : 12;

            if (isLeftFoot) {
                createFootprint(leftX - deviation, leftY - deviation, true, angle);
            } else {
                createFootprint(rightX - deviation, rightY - deviation, false, angle);
            }

            isLeftFoot = !isLeftFoot;
            currentPosition += 25;

            // 到尾端時，把位置 cap 在 pathLength，下一次會由 startCycle 的 timeout 轉入 waitingRestart
            if (currentPosition > pathLength - 24) {
                currentPosition = pathLength - 24;
                // ribbon 消失
                // ribbonGroup.style.display = "none";
            }
        }
        //#endregion

        // 取得 URL 參數
        function getSeatIdFromURL() {
            let params = new URLSearchParams(window.location.search);
            return params.get("id"); // 取得 ?id=xxx 的值
        }

        // 模擬掃描 QR Code
        function onScanQRCode(seatId) {
            const originX = 960, originY = 2060;
            let guest = guests.filter(g => g.id == seatId);

            if (guest.length == 0) {
                alert("座位不存在！");
                $('#loading-screen').show();
                $('.loader').hide();
                return;
            }

            $('#guestName').text(guest[0].name);

            const college = seatId[0];
            const tableNo = parseInt(seatId[1], 10);
            const seatNo = parseInt(seatId[2], 10);

            // 計算座標 Y
            let targetY = 375 + (tableNo - 1) * 222;
            if (tableNo > 4) targetY += 115; //4~5桌間距
            if(seatNo == 3 || seatNo == 4) {
                targetY += 70;
            }
            else if(seatNo == 5 || seatNo == 6) {
                targetY += 140;
            }
            // motion Y 偏移
            const motionY = targetY - originY;

            // S/H → 往左, G/R → 往右
            const leftSide = (college === "S" || college === "H");
            const leftSideSeat = seatNo % 2 != 0;
            const sign = leftSide ? -1 : 1;
            const seatSign = leftSideSeat ? 1 : -1;


            // 路線點 (svg 的絕對座標)
            let points = [[originX, originY]];
            // motionPath 點 (相對座標)
            let mPoints = [[0, 0]];

            if((college === "H" && !leftSideSeat) || (college === "G" && leftSideSeat)){
                // 垂直線 (origin → targetY)
                points.push([originX, targetY]);
                mPoints.push([0, motionY]);

                // 偏移 (往內 130, -30)
                points.push([originX + 130 * seatSign, targetY - 30]);
                mPoints.push([120 * seatSign, motionY - 30]);
            }
            else if((college === "S" && leftSideSeat) || (college === "R" && !leftSideSeat)){
                // 橫線 (origin → 左右 820px)
                points.push([originX + 820 * sign, originY]);
                mPoints.push([840 * sign, 0]);

                // 垂直線
                points.push([originX + 820 * sign, targetY]);
                mPoints.push([840 * sign, motionY]);

                // 偏移 (再往內 80, -30)
                points.push([originX + 820 * sign - 80 * sign, targetY - 30]);
                mPoints.push([840 * sign - 100 * sign, motionY - 30]);
            }
            else{
                // 橫線 (origin → 左右 820px)
                points.push([originX + 445 * sign, originY]);
                mPoints.push([445 * sign, 0]);

                // 垂直線 (origin → targetY)
                points.push([originX + 445 * sign, targetY]);
                mPoints.push([445 * sign, motionY]);

                // 偏移 (往內 80, -30)
                points.push([originX + 445 * sign + 80 * seatSign, targetY - 30]);
                mPoints.push([445 * sign + 80 * seatSign, motionY - 30]);
            }

            // 轉成 path 字串
            const routeD = "M" + points.map(p => p.join(" ")).join(" L");
            const motionD = "M" + mPoints.map(p => p.join(" ")).join(" L");

            route.setAttribute("d", routeD);
            motionPath.setAttribute("d", motionD);
        }


        //漂浮效果
        function floatElement(id) {
            var newTop = baseTop[id] + (Math.random() * 20 - 10); // 上下隨機漂浮 ±10px
            $('#' + id).animate({ top: newTop }, 2000, function () {
                floatElement(id); // 動畫完成後繼續漂浮
            });
        }

        /*檢核手機轉向*/
        function checkOrientation() {
            const overlay = document.getElementById('orientation-overlay');

            if (window.matchMedia("(orientation: portrait)").matches) {
                overlay.classList.add("show"); // 顯示遮罩 (淡入)
                document.body.style.overflow = "hidden"; // 禁止滾動
            } else {
                overlay.classList.remove("show"); // 隱藏遮罩 (淡出)
                document.body.style.overflow = "auto"; // 恢復滾動
            }
        }
    </script>

</body>

</html>